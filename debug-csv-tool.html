<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Data Graph Visualizer</title>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .container {
            border: 1px solid #ccc;
            padding: 2rem;
            border-radius: 8px;
            background: #f9f9f9;
        }

        h1 {
            margin-top: 0;
        }

        .upload-area {
            margin: 2rem 0;
            border: 2px dashed #aaa;
            padding: 2rem;
            text-align: center;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            transition: background 0.3s;
        }

        .upload-area:hover {
            background: #f0f8ff;
            border-color: #007bff;
        }

        #log {
            white-space: pre-wrap;
            background: #333;
            color: #0f0;
            padding: 1rem;
            border-radius: 4px;
            font-family: monospace;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 2rem;
        }

        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Chart Layout */
        #charts-container {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-wrapper {
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        canvas {
            width: 100% !important;
            height: 300px !important;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Gaze Data Graph Visualizer</h1>
        <p>Upload a CSV file to visualize gaze data analysis graphs instantly.</p>

        <div class="upload-area" id="dropZone">
            <p>Drag & Drop CSV file here or click to upload</p>
            <input type="file" id="fileInput" accept=".csv,.txt" style="display: none;">
            <button class="btn" onclick="document.getElementById('fileInput').click()">Select File</button>
        </div>

        <div id="log">Ready. Waiting for file...</div>

        <div id="charts-container">
            <!-- Charts will be injected here -->
        </div>
    </div>

    <script>
        // --- 1. Core Algorithms (Inlined from velx-spike-detector.js) ---

        function median(arr) {
            const a = arr.filter(Number.isFinite).slice().sort((x, y) => x - y);
            const n = a.length;
            if (n === 0) return NaN;
            const mid = Math.floor(n / 2);
            return n % 2 ? a[mid] : (a[mid - 1] + a[mid]) / 2;
        }

        function mad(arr, med) {
            return median(arr.filter(Number.isFinite).map(v => Math.abs(v - med)));
        }

        function detectVelXSpikes(samples, { k = 3.0, gapMs = 120, expandOneSample = true } = {}) {
            const ts = samples.map(s => Number(s.ts_ms));
            const velX = samples.map(s => Number(s.velX));
            const absVel = velX.map(v => Math.abs(v));

            const med = median(absVel);
            let m = mad(absVel, med);
            let scale = 1.4826 * m;

            if (!Number.isFinite(scale) || scale < 1e-12) {
                const finite = absVel.filter(Number.isFinite);
                const mean = finite.reduce((a, b) => a + b, 0) / Math.max(1, finite.length);
                const varr = finite.reduce((a, v) => { const d = v - mean; return a + d * d; }, 0) / Math.max(1, finite.length - 1);
                const std = Math.sqrt(varr);
                scale = std > 1e-12 ? std : 1.0;
            }

            const threshold = med + k * scale;
            const spikeMask = absVel.map(v => Number.isFinite(v) && v > threshold);

            const idx = [];
            for (let i = 0; i < spikeMask.length; i++) if (spikeMask[i]) idx.push(i);

            let segments = [];
            if (idx.length) {
                let s = idx[0], p = idx[0];
                for (let j = 1; j < idx.length; j++) {
                    const i = idx[j];
                    if (i === p + 1) p = i;
                    else { segments.push([s, p]); s = i; p = i; }
                }
                segments.push([s, p]);
            }

            if (expandOneSample) {
                segments = segments.map(([a, b]) => [Math.max(0, a - 1), Math.min(samples.length - 1, b + 1)]);
            }

            const timeSegments = segments.map(([a, b]) => [ts[a], ts[b], a, b]);
            const merged = [];
            for (const seg of timeSegments) {
                if (!merged.length) merged.push(seg.slice());
                else {
                    const last = merged[merged.length - 1];
                    if (seg[0] - last[1] <= gapMs) { last[1] = seg[1]; last[3] = seg[3]; }
                    else merged.push(seg.slice());
                }
            }

            const spikeIntervals = merged.map(([start_ms, end_ms, aIdx, bIdx]) => {
                let peak = 0;
                for (let i = aIdx; i <= bIdx; i++) peak = Math.max(peak, Math.abs(velX[i]) || 0);
                return { start_ms, end_ms, duration_ms: end_ms - start_ms, peakAbsVelX: peak, startIndex: aIdx, endIndex: bIdx };
            });

            return { threshold, spikeIntervals, spikeMask };
        }

        // --- 2. Logic (Ported from GazeDataManager & debug-reprocess.mjs) ---

        function log(msg) {
            const el = document.getElementById('log');
            el.innerText += msg + "\n";
            el.scrollTop = el.scrollHeight;
            console.log(msg);
        }

        function processFile(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const content = e.target.result;
                log(`File loaded. Size: ${content.length} bytes.`);
                runAlgo(content, file.name);
            };
            reader.readAsText(file);
        }

        function runAlgo(rawContent, filename) {
            log("Parsing CSV for Visualization (Skipping Reprocessing)...");
            const lines = rawContent.split(/\r?\n/).filter(line => line.trim() !== '');
            const data = [];
            let firstTimestamp = null;
            let ignoredLines = 0;

            // Column Mapping (Init with -1)
            let colMap = {
                t: -1, x: -1, y: -1,
                gx: -1, gy: -1,
                vx: -1, vy: -1,
                lineIndex: -1, charIndex: -1,
                targetY: -1, avgY: -1,
                algoLineIndex: -1,
                isReturnSweep: -1,
                extrema: -1,
                rx: -1, ry: -1
            };

            let startRow = 0;
            let delimiter = ',';

            // 1. Detect Delimiter & Header
            if (lines.length > 0) {
                const firstLine = lines[0].trim();

                // Delimiter check
                const commaCount = (firstLine.match(/,/g) || []).length;
                const tabCount = (firstLine.match(/\t/g) || []).length;
                if (tabCount > commaCount) delimiter = '\t';

                const parts = firstLine.split(delimiter).map(s => s.trim().toLowerCase());

                // Header Detection
                if (isNaN(parseFloat(parts[0]))) {
                    log(`Header detected. Delimiter: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);

                    parts.forEach((p, i) => {
                        // Time
                        if (p.includes('relative') || p.includes('time') || p === 't') colMap.t = i;
                        // Raw
                        else if (p === 'rawx' || p === 'x') colMap.x = i;
                        else if (p === 'rawy' || p === 'y') colMap.y = i;
                        // Smooth
                        else if (p === 'smoothx' || p === 'gx') colMap.gx = i;
                        else if (p === 'smoothy' || p === 'gy') colMap.gy = i;
                        // Velocity
                        else if (p === 'velx' || p === 'vx') colMap.vx = i;
                        else if (p === 'vely' || p === 'vy') colMap.vy = i;
                        // Indices
                        else if (p === 'lineindex') colMap.lineIndex = i;
                        else if (p === 'charindex') colMap.charIndex = i;
                        else if (p === 'algolineindex' || p.includes('algo')) colMap.algoLineIndex = i;
                        // Metadata
                        else if (p.includes('targety')) colMap.targetY = i;
                        else if (p.includes('avgcool')) colMap.avgY = i;
                        else if (p.includes('returnsweep')) colMap.isReturnSweep = i;
                        else if (p.includes('extrema')) colMap.extrema = i;
                        // Replay
                        else if (p.includes('replayx')) colMap.rx = i;
                        else if (p.includes('replayy')) colMap.ry = i;
                    });

                    startRow = 1;
                } else {
                    // No Header - Default Mapping (Assume Raw Format)
                    log("No Header detected. Using default Raw indices (T=0, X=1, Y=2).");
                    colMap.t = 0; colMap.x = 1; colMap.y = 2;
                }
            }

            log(`Mapped Columns: T=${colMap.t}, X=${colMap.x}, SmoothX=${colMap.gx}, LineIndex=${colMap.lineIndex}, AlgoIdx=${colMap.algoLineIndex}, Rx=${colMap.rx}, Ry=${colMap.ry}`);

            // 2. Parse Data
            let lastValidLineIndex = null;

            for (let i = startRow; i < lines.length; i++) {
                const line = lines[i];
                const parts = line.split(delimiter).map(s => s.trim());

                if (parts.length < 2) { ignoredLines++; continue; }

                // Safe Parse Helper
                const getVal = (idx) => {
                    if (idx === -1 || idx >= parts.length) return null;
                    const val = parts[idx];
                    if (val === "" || val === "null" || val === undefined) return null;
                    const num = parseFloat(val);
                    return isNaN(num) ? val : num; // Return number if possible, else string (for extrema/type)
                };

                const t = getVal(colMap.t);
                if (t === null || typeof t !== 'number') continue; // Timestamp is mandatory

                // Parsing Logic
                let lIdx = getVal(colMap.lineIndex);
                // Carry-Forward LineIndex Logic
                if (lIdx !== null && typeof lIdx === 'number') {
                    lastValidLineIndex = lIdx;
                } else {
                    lIdx = lastValidLineIndex;
                }

                const gx = getVal(colMap.gx);
                const gy = getVal(colMap.gy);

                // Return Sweep Parsing (Boolean check)
                let isRS = false;
                const rsVal = getVal(colMap.isReturnSweep);
                if (rsVal === "TRUE" || rsVal === "true" || rsVal === true) isRS = true;

                data.push({
                    t: t,
                    x: getVal(colMap.x),
                    y: getVal(colMap.y),
                    gx: gx,
                    gy: gy,
                    vx: getVal(colMap.vx),
                    vy: getVal(colMap.vy),
                    lineIndex: lIdx,
                    charIndex: getVal(colMap.charIndex),
                    targetY: getVal(colMap.targetY),
                    avgY: getVal(colMap.avgY),
                    detectedLineIndex: getVal(colMap.algoLineIndex),
                    extrema: getVal(colMap.extrema),
                    isReturnSweep: isRS,
                    rx: getVal(colMap.rx),
                    ry: getVal(colMap.ry),
                    type: 'Unknown' // Not critically used in viz
                });
            }

            log(`Loaded ${data.length} valid rows. (Ignored ${ignoredLines} lines)`);
            log("Skipping internal reprocessing (Interpolation/Smoothing/Detection) as requested.");

            if (data.length < 10) {
                log("Warning: Less than 10 data points loaded.");
            }

            // Directly Render
            log("Rendering Charts with CSV Data...");
            setTimeout(() => renderCharts(data), 100);
        }

        function preprocessData(geoData) {
            // 1. Interpolation
            for (let i = 0; i < geoData.length; i++) {
                const curr = geoData[i];
                const isMissing = curr.x === null || curr.y === null || (curr.x === 0 && curr.y === 0) || isNaN(curr.x);
                if (isMissing) {
                    let prevIdx = i - 1;
                    while (prevIdx >= 0) {
                        const p = geoData[prevIdx];
                        if (p.x !== null && !isNaN(p.x) && (p.x !== 0 || p.y !== 0)) break;
                        prevIdx--;
                    }
                    let nextIdx = i + 1;
                    while (nextIdx < geoData.length) {
                        const n = geoData[nextIdx];
                        if (n.x !== null && !isNaN(n.x) && (n.x !== 0 || n.y !== 0)) break;
                        nextIdx++;
                    }
                    if (prevIdx >= 0 && nextIdx < geoData.length) {
                        const p = geoData[prevIdx];
                        const n = geoData[nextIdx];
                        const ratio = (curr.t - p.t) / (n.t - p.t);
                        curr.x = p.x + (n.x - p.x) * ratio;
                        curr.y = p.y + (n.y - p.y) * ratio;
                    } else if (prevIdx >= 0) {
                        curr.x = geoData[prevIdx].x;
                        curr.y = geoData[prevIdx].y;
                    } else if (nextIdx < geoData.length) {
                        curr.x = geoData[nextIdx].x;
                        curr.y = geoData[nextIdx].y;
                    }
                }
            }

            // 2. Smoothing
            const sigma = 3;
            const radius = Math.ceil(3 * sigma);
            const kernelSize = 2 * radius + 1;
            const kernel = new Float32Array(kernelSize);
            let sumK = 0;
            for (let i = 0; i < kernelSize; i++) {
                const x = i - radius;
                const val = Math.exp(-(x * x) / (2 * sigma * sigma));
                kernel[i] = val;
                sumK += val;
            }
            for (let i = 0; i < kernelSize; i++) kernel[i] /= sumK;

            for (let i = 0; i < geoData.length; i++) {
                let sumX = 0, sumY = 0, wSum = 0;
                for (let k = 0; k < kernelSize; k++) {
                    const idx = i + (k - radius);
                    if (idx >= 0 && idx < geoData.length) {
                        if (geoData[idx].x !== null) {
                            sumX += geoData[idx].x * kernel[k];
                            sumY += geoData[idx].y * kernel[k];
                            wSum += kernel[k];
                        }
                    }
                }
                if (wSum > 0) {
                    geoData[i].gx = sumX / wSum;
                    geoData[i].gy = sumY / wSum;
                } else {
                    geoData[i].gx = geoData[i].x;
                    geoData[i].gy = geoData[i].y;
                }
            }

            // 3. Velocity
            for (let i = 0; i < geoData.length; i++) {
                if (i === 0) {
                    geoData[i].vx = 0;
                    geoData[i].vy = 0;
                } else {
                    const dt = geoData[i].t - geoData[i - 1].t;
                    if (dt > 0) {
                        // User Request: Use Raw X/Y for Velocity
                        geoData[i].vx = (geoData[i].x - geoData[i - 1].x) / dt;
                        geoData[i].vy = (geoData[i].y - geoData[i - 1].y) / dt;
                    } else {
                        geoData[i].vx = 0;
                        geoData[i].vy = 0;
                    }
                }
            }
        }

        function detectLinesMobile(geoData) {
            if (geoData.length < 10) return;

            // Use all data
            const samples = geoData.map(d => ({ ts_ms: d.t, velX: d.vx }));

            // *** K = 2.0 (Updated) ***
            const { threshold, spikeIntervals } = detectVelXSpikes(samples, { k: 2.0, gapMs: 120, expandOneSample: true });

            // 4. Identify Potential Return Sweeps
            const candidates = spikeIntervals.filter(interval => {
                let sum = 0;
                let count = 0;
                for (let i = interval.startIndex; i <= interval.endIndex; i++) {
                    if (i >= 0 && i < samples.length) {
                        sum += samples[i].velX;
                        count++;
                    }
                }
                const meanVel = count > 0 ? sum / count : 0;
                if (meanVel >= 0) return false;

                // Also check displacement
                const sIdx = interval.startIndex;
                const eIdx = interval.endIndex;
                if (geoData[sIdx] && geoData[eIdx]) {
                    const disp = geoData[sIdx].gx - geoData[eIdx].gx;
                    return disp > 100;
                }
                return false;
            });

            candidates.sort((a, b) => a.start_ms - b.start_ms);

            // --- Advanced Validation (Algorithm 1 & 2) ---
            // 0. Dynamic Threshold Calculation
            let observedMinLineDur = Infinity;
            let curLineIdxForDur = -1;
            let curLineStartTForDur = -1;

            for (let i = 0; i < geoData.length; i++) {
                const d = geoData[i];
                if (d.lineIndex !== null && d.lineIndex !== undefined && d.lineIndex !== "") {
                    const idx = Number(d.lineIndex);
                    if (idx !== curLineIdxForDur) {
                        if (curLineIdxForDur !== -1) {
                            const duration = d.t - curLineStartTForDur;
                            if (duration > 50 && duration < observedMinLineDur) {
                                observedMinLineDur = duration;
                            }
                        }
                        curLineIdxForDur = idx;
                        curLineStartTForDur = d.t;
                    }
                }
            }
            if (observedMinLineDur === Infinity) observedMinLineDur = 300;

            const MIN_LINE_DURATION = observedMinLineDur * 0.5;
            log(`[Dynamic Threshold] MinObserved=${observedMinLineDur}ms -> Threshold=${MIN_LINE_DURATION}ms`);

            const validSweeps = [];
            let currentLineNum = 1;
            let lastSweepEndTime = -Infinity;

            for (const sweep of candidates) {
                const sweepData = geoData[sweep.startIndex];
                const sweepTime = sweepData.t;

                // Algo 2: Time Gap
                const timeSinceLast = sweepData.t - lastSweepEndTime;
                if (validSweeps.length > 0 && timeSinceLast < MIN_LINE_DURATION) {
                    log(`[Reject Sweep] Rapid Fire: dt=${timeSinceLast}ms < ${MIN_LINE_DURATION}ms at T=${sweepTime}`);
                    continue;
                }

                // Algo 1: LineNum Constraint
                // Note: carry-forward logic is assumed to be handled during load
                let currentLineIndex = sweepData.lineIndex;
                if (currentLineIndex !== null && currentLineIndex !== undefined) {
                    const visibleLines = Number(currentLineIndex) + 1;
                    const targetLineNum = currentLineNum + 1;

                    if (targetLineNum > visibleLines) {
                        log(`[Reject Sweep] Premature: TargetLine ${targetLineNum} > VisibleLines ${visibleLines} at T=${sweepTime}`);
                        continue;
                    }
                }

                validSweeps.push(sweep);
                lastSweepEndTime = sweep.end_ms;
                currentLineNum++;
            }

            let lineNum = 1;
            let lastEndRelIdx = 0;

            const markLine = (relStart, relEnd, num) => {
                if (relEnd <= relStart) return;
                for (let k = relStart; k < relEnd; k++) {
                    if (geoData[k]) geoData[k].detectedLineIndex = num;
                }
                if (geoData[relStart]) geoData[relStart].extrema = "LineStart";
                if (geoData[relEnd - 1]) geoData[relEnd - 1].extrema = "PosMax";
            };

            for (const sweep of validSweeps) {
                const lineEndRelIdx = sweep.startIndex;
                if (lineEndRelIdx - lastEndRelIdx > 5) {
                    markLine(lastEndRelIdx, lineEndRelIdx, lineNum);
                    lineNum++;
                }
                lastEndRelIdx = sweep.endIndex + 1;
                for (let k = sweep.startIndex; k <= sweep.endIndex; k++) {
                    if (geoData[k]) geoData[k].isReturnSweep = true;
                }
            }

            if (samples.length - lastEndRelIdx > 5) {
                markLine(lastEndRelIdx, samples.length, lineNum);
            }

            log(`Detection Complete: Found ${lineNum} lines.`);
        }

        function exportCSV(data, originalFilename) {
            let csvHeader = "RelativeTimestamp_ms,RawX,RawY,SmoothX,SmoothY,VelX,VelY,Type,ReturnSweep,LineIndex,CharIndex,AlgoLineIndex,Extrema\n";
            let csvContent = csvHeader;

            data.forEach(d => {
                const row = [
                    d.t,
                    d.x !== null ? d.x : "",
                    d.y !== null ? d.y : "",
                    d.gx !== null ? d.gx.toFixed(2) : "",
                    d.gy !== null ? d.gy.toFixed(2) : "",
                    d.vx !== null ? d.vx.toFixed(4) : "",
                    d.vy !== null ? d.vy.toFixed(4) : "",
                    d.type,
                    (d.isReturnSweep ? "TRUE" : ""),
                    (d.lineIndex !== null && d.lineIndex !== undefined) ? d.lineIndex : "",
                    (d.charIndex !== null && d.charIndex !== undefined) ? d.charIndex : "",
                    (d.detectedLineIndex !== undefined) ? d.detectedLineIndex : "",
                    (d.extrema !== undefined) ? d.extrema : ""
                ];
                csvContent += row.join(",") + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);

            const newName = originalFilename.replace(/\.(csv|txt)$/i, "") + "_processed_k2.0.csv";

            link.href = url;
            link.setAttribute("download", newName);
            link.style.display = "none";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            log(`Triggered download for: ${newName}`);
        }

        // --- 4. Chart Rendering ---

        let algoCharts = [];

        function renderCharts(data) {
            const container = document.getElementById('charts-container');
            container.innerHTML = ''; // Clear previous

            // Destroy previous Chart instances if re-running
            algoCharts.forEach(c => c.destroy());
            algoCharts = [];

            // Common Axis: RelativeTimestamp_ms
            const labels = data.map(d => d.t);

            // Prepare Return Sweep Intervals for Plugin
            const returnSweepIntervals = [];
            let rStart = null;
            for (let i = 0; i < data.length; i++) {
                if (data[i].isReturnSweep) {
                    if (rStart === null) rStart = data[i].t;
                } else {
                    if (rStart !== null) {
                        returnSweepIntervals.push({ start: rStart, end: data[i - 1].t });
                        rStart = null;
                    }
                }
            }
            if (rStart !== null) returnSweepIntervals.push({ start: rStart, end: data[data.length - 1].t });

            const shadingPlugin = {
                id: 'returnSweepShading',
                beforeDatasetsDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    if (!chartArea) return;
                    const x = scales.x;
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.2)'; // Magenta tint for Return Sweeps

                    for (const it of returnSweepIntervals) {
                        const x0 = x.getPixelForValue(it.start);
                        const x1 = x.getPixelForValue(it.end);
                        if (Number.isFinite(x0) && Number.isFinite(x1)) {
                            ctx.fillRect(Math.min(x0, x1), chartArea.top, Math.abs(x1 - x0), chartArea.bottom - chartArea.top);
                        }
                    }
                    ctx.restore();
                }
            };

            const createCanvas = (id, title, isUpdate = false) => {
                let canvas = document.getElementById(id);
                if (canvas && isUpdate) {
                    // Update Title
                    const h3 = canvas.previousElementSibling;
                    if (h3) h3.innerText = title;
                    return canvas.getContext('2d');
                }

                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                wrapper.innerHTML = `<h3>${title}</h3><canvas id="${id}"></canvas>`;
                container.appendChild(wrapper);
                return document.getElementById(id).getContext('2d');
            };

            // --- Chart 1: RawX, RawY ---
            const ctx1 = createCanvas('chart1', "Chart 1: Raw X/Y");
            const chart1 = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'RawX', data: data.map(d => d.x), borderColor: '#888', borderWidth: 1, pointRadius: 0 },
                        { label: 'RawY', data: data.map(d => d.y), borderColor: '#ffcc00', borderWidth: 1, pointRadius: 0 }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { maxTicksLimit: 20 } } } },
                plugins: [shadingPlugin]
            });
            algoCharts.push(chart1);

            // --- Chart 2: SmoothY, TargetY, AvgCoolGazeY, ReplayY ---
            const ctx2 = createCanvas('chart2', "Chart 2: Vertical Y Analysis");
            const chart2 = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'SmoothY', data: data.map(d => d.gy), borderColor: 'orange', borderWidth: 1.5, pointRadius: 0 },
                        { label: 'TargetY_Px', data: data.map(d => d.targetY), borderColor: 'blue', borderWidth: 2, pointRadius: 0, stepped: true },
                        { label: 'AvgCoolGazeY_Px', data: data.map(d => d.avgY), borderColor: 'green', borderWidth: 2, pointRadius: 0, borderDash: [5, 5], stepped: true },
                        { label: 'ReplayY', data: data.map(d => d.ry), borderColor: '#9932CC', borderWidth: 2, pointRadius: 0, borderDash: [2, 2] } // DarkOrchid Dashed
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { maxTicksLimit: 20 } } } },
                plugins: [shadingPlugin]
            });
            algoCharts.push(chart2);

            // --- Chart 3: SmoothX, Extrema, ReturnSweep, ReplayX ---
            const lineStarts = data.map(d => d.extrema === 'LineStart' ? d.gx : null);
            const posMaxs = data.map(d => d.extrema === 'PosMax' ? d.gx : null);

            const ctx3 = createCanvas('chart3', "Chart 3: SmoothX & Extrema & ReturnSweeps");
            const chart3 = new Chart(ctx3, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'SmoothX', data: data.map(d => d.gx), borderColor: 'blue', borderWidth: 1.5, pointRadius: 0 },
                        { label: 'ReplayX', data: data.map(d => d.rx), borderColor: '#00FFFF', borderWidth: 2, pointRadius: 0, borderDash: [2, 2] }, // Cyan Dashed
                        { label: 'ReturnSweep', data: data.map(d => d.isReturnSweep ? d.gx : null), type: 'scatter', backgroundColor: 'magenta', pointStyle: 'rectRot', radius: 4 },
                        { label: 'LineStart', data: lineStarts, type: 'scatter', backgroundColor: 'green', pointStyle: 'triangle', radius: 6, rotation: 180 },
                        { label: 'PosMax', data: posMaxs, type: 'scatter', backgroundColor: 'red', pointStyle: 'triangle', radius: 6 }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { maxTicksLimit: 20 } } }, plugins: { legend: { labels: { usePointStyle: true } } } },
                plugins: [shadingPlugin]
            });
            algoCharts.push(chart3);

            // --- Chart 4: VelX, VelY ---
            const ctx4 = createCanvas('chart4', "Chart 4: Velocity X/Y");
            const chart4 = new Chart(ctx4, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'VelX', data: data.map(d => d.vx), borderColor: 'purple', borderWidth: 1, pointRadius: 0 },
                        { label: 'VelY', data: data.map(d => d.vy), borderColor: 'brown', borderWidth: 1, pointRadius: 0 }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { maxTicksLimit: 20 } } } }
            });
            algoCharts.push(chart4);

            // --- Chart 5: LineIndex, AlgoLineIndex ---
            const ctx5 = createCanvas('chart5', "Chart 5: Line Indices");
            const chart5 = new Chart(ctx5, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'LineIndex',
                            data: data.map(d => d.lineIndex),
                            borderColor: 'rgba(0, 255, 255, 0.6)',
                            backgroundColor: 'rgba(0, 255, 255, 0.1)',
                            borderWidth: 8, // Very thick
                            stepped: true,
                            pointRadius: 0
                        },
                        {
                            label: 'AlgoLineIndex',
                            data: data.map(d => d.detectedLineIndex),
                            borderColor: '#ff00ff',
                            borderWidth: 2,
                            borderDash: [0, 0], // Solid line for visibility
                            stepped: true,
                            pointRadius: 3, // Add points to make it stand out on top
                            pointBackgroundColor: '#ff00ff'
                        }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { maxTicksLimit: 20 } } } }
            });
            algoCharts.push(chart5);

            // --- Chart 6: CharIndex ---
            const ctx6 = createCanvas('chart6', "Chart 6: Char Index");
            const chart6 = new Chart(ctx6, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'CharIndex', data: data.map(d => d.charIndex), borderColor: 'black', borderWidth: 2, pointRadius: 0, stepped: true }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { maxTicksLimit: 20 } } } }
            });
            algoCharts.push(chart6);

            // --- Chart 7: Replay X/Y Combined with ReturnSweep ---
            const ctx7 = createCanvas('chart7', "Chart 7: Replay X/Y & ReturnSweep");
            const chart7 = new Chart(ctx7, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'ReplayX', data: data.map(d => d.rx), borderColor: '#00FFFF', borderWidth: 2, pointRadius: 0 },
                        { label: 'ReplayY', data: data.map(d => d.ry), borderColor: '#9932CC', borderWidth: 2, pointRadius: 0 },
                        {
                            label: 'ReturnSweep',
                            data: data.map(d => d.isReturnSweep ? d.rx || d.gx : null), // Fallback to SmoothX if ReplayX is null
                            type: 'scatter',
                            backgroundColor: 'magenta',
                            pointStyle: 'rectRot',
                            radius: 4
                        }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { maxTicksLimit: 20 } } }, plugins: { legend: { labels: { usePointStyle: true } } } },
                plugins: [shadingPlugin]
            });
            algoCharts.push(chart7);

            // --- Chart 8: Spatial Plot (RawX vs RawY) with Target Lines ---
            const maxX = Math.max(...data.map(d => typeof d.x === 'number' ? d.x : 0), 1000);
            // Filter unique TargetY values
            const uniqueTargetYs = [...new Set(data.map(d => d.targetY))].filter(y => y !== null && y !== "" && !isNaN(y)).sort((a, b) => a - b);

            // Color Palette for Segments
            const segmentColors = [
                'rgba(255, 0, 0, 0.6)',    // Red
                'rgba(255, 140, 0, 0.6)',  // Dark Orange
                'rgba(200, 200, 0, 0.6)',  // Darker Yellow (for visibility)
                'rgba(0, 150, 0, 0.6)',    // Green
                'rgba(0, 0, 255, 0.6)',    // Blue
                'rgba(75, 0, 130, 0.6)',   // Indigo
                'rgba(148, 0, 211, 0.6)',  // Violet
                'rgba(0, 139, 139, 0.6)',  // Dark Cyan
                'rgba(128, 0, 0, 0.6)',    // Maroon
                'rgba(85, 107, 47, 0.6)'   // Olive
            ];

            const spatialDatasets = [];
            const sweepPoints = [];

            let currentSegment = [];
            let segIndex = 0;
            let isInSweep = false;

            data.forEach((d, i) => {
                // User Request: Force X to 100 for all points
                const pt = { x: 100, y: d.y };

                if (d.isReturnSweep) {
                    sweepPoints.push(pt);

                    // If we were not in a sweep, this marks the end of a segment
                    if (!isInSweep) {
                        if (currentSegment.length > 0) {
                            spatialDatasets.push({
                                label: `Segment ${segIndex + 1}`,
                                data: [...currentSegment],
                                backgroundColor: segmentColors[segIndex % segmentColors.length],
                                pointRadius: 3,
                                type: 'scatter'
                            });
                            currentSegment = [];
                            segIndex++;
                        }
                        isInSweep = true;
                    }
                } else {
                    // Reset sweep flag if we are back to normal
                    if (isInSweep) {
                        isInSweep = false;
                    }
                    currentSegment.push(pt);
                }
            });

            // Add remaining segment
            if (currentSegment.length > 0) {
                spatialDatasets.push({
                    label: `Segment ${segIndex + 1}`,
                    data: [...currentSegment],
                    backgroundColor: segmentColors[segIndex % segmentColors.length],
                    pointRadius: 3,
                    type: 'scatter'
                });
            }

            // Add Return Sweeps Dataset (Visualized on top)
            if (sweepPoints.length > 0) {
                spatialDatasets.push({
                    label: 'Return Sweep',
                    data: sweepPoints,
                    backgroundColor: 'rgba(255, 0, 255, 0.9)', // Bright Magenta
                    pointRadius: 4,
                    pointStyle: 'triangle',
                    type: 'scatter'
                });
            }

            // Add Lines for TargetY
            uniqueTargetYs.forEach((yVal, idx) => {
                spatialDatasets.push({
                    label: `Line Y=${yVal}`,
                    data: [{ x: 0, y: yVal }, { x: maxX, y: yVal }], // Horizontal line
                    type: 'line',
                    borderColor: 'rgba(255, 0, 0, 0.8)',
                    borderWidth: 1,
                    pointRadius: 0,
                    borderDash: [5, 5],
                    fill: false
                });
            });

            const ctx8 = createCanvas('chart8', "Chart 8: Spatial Gaze Plot (RawX vs RawY) - Color Coded by Line Segment");
            const chart8 = new Chart(ctx8, {
                data: { datasets: spatialDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            reverse: true, // Screen coordinate system (Y goes down)
                            title: { display: true, text: 'Raw Y (Px) - Reversed' },
                            beginAtZero: true
                        },
                        x: {
                            position: 'top',
                            title: { display: true, text: 'Raw X (Px)' },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                filter: function (item, chart) {
                                    // Show Segments and Return Sweep, hide individual target lines to save space if needed
                                    // But showing target line legend is okay.
                                    return true;
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    if (context.dataset.type === 'line') return `Target Line Y: ${context.parsed.y}`;
                                    return `(${context.parsed.x}, ${context.parsed.y}) [${context.dataset.label}]`;
                                }
                            }
                        }
                    }
                }
            });
            algoCharts.push(chart8);

            // --- Chart 9: Positive VelY Spike Detection (k=2.0) ---
            // Detect Positive VelY spikes (Downward movement = Line Breaks)
            const velySamples = data.map(d => ({
                ts_ms: d.t,
                velX: (typeof d.vy === 'number' && d.vy > 0) ? d.vy : 0 // FILTER: Positive Only
            }));

            const velYResult = detectVelXSpikes(velySamples, { k: 2.0, gapMs: 120, expandOneSample: true });

            // Map spikes back to data for visualization
            const velYSpikePoints = [];
            velYResult.spikeIntervals.forEach(interval => {
                for (let k = interval.startIndex; k <= interval.endIndex; k++) {
                    if (data[k] && data[k].vy > 0) velYSpikePoints.push({ x: data[k].t, y: data[k].vy });
                }
            });

            const ctx9 = createCanvas('chart9', "Chart 9: Positive Vertical Velocity (VelY > 0) Analysis (k=2.0)");
            const chart9 = new Chart(ctx9, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Positive VelY',
                            data: data.map(d => (d.vy > 0 ? d.vy : 0)), // Display only positive
                            borderColor: 'brown',
                            borderWidth: 1,
                            pointRadius: 0
                        },
                        {
                            label: 'Detected Spikes (k=1.0)',
                            data: velYSpikePoints,
                            type: 'scatter',
                            backgroundColor: 'red',
                            pointRadius: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { ticks: { maxTicksLimit: 20 } },
                        y: { beginAtZero: true, min: 0 } // Force Y axis to start at 0
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                thresholdLine: {
                                    type: 'line',
                                    yMin: velYResult.threshold,
                                    yMax: velYResult.threshold,
                                    borderColor: 'rgba(255, 0, 0, 0.5)',
                                    borderWidth: 1,
                                    borderDash: [5, 5],
                                    label: {
                                        content: `Threshold: ${velYResult.threshold.toFixed(2)}`,
                                        enabled: true
                                    }
                                }
                            }
                        }
                    }
                }
            });
            algoCharts.push(chart9);

            // --- Chart 10: Recalculated Velocity from Raw X/Y ---
            // Independent calculation using RawX/Y from CSV
            const reCalcVelX = [];
            const reCalcVelY = [];

            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    reCalcVelX.push(0);
                    reCalcVelY.push(0);
                } else {
                    const dt = data[i].t - data[i - 1].t;
                    if (dt > 0) {
                        const vx = (data[i].x - data[i - 1].x) / dt;
                        const vy = (data[i].y - data[i - 1].y) / dt;
                        reCalcVelX.push(vx);
                        reCalcVelY.push(vy);
                    } else {
                        reCalcVelX.push(0);
                        reCalcVelY.push(0);
                    }
                }
            }

            const ctx10 = createCanvas('chart10', "Chart 10: Recalculated Velocity from Raw X/Y (Independent)");
            const chart10 = new Chart(ctx10, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Recalculated VelX', data: reCalcVelX, borderColor: '#9370DB', borderWidth: 1, pointRadius: 0 }, // MediumPurple
                        { label: 'Recalculated VelY', data: reCalcVelY, borderColor: '#CD853F', borderWidth: 1, pointRadius: 0 }  // Peru
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { x: { ticks: { maxTicksLimit: 20 } } }
                }
            });
            algoCharts.push(chart10);

            // --- Chart 11: Independent Return Sweep Detection & Visualization (Like Chart 3) ---
            // UI Calculation for K value
            let dynamicK = 2.0; // Default

            // Function to Render Chart 11
            function renderChart11(kVal) {
                // Remove existing chart 11 from array if present
                const existingIndex = algoCharts.findIndex(c => c.canvas.id === 'chart11');
                if (existingIndex !== -1) {
                    algoCharts[existingIndex].destroy();
                    algoCharts.splice(existingIndex, 1);
                }

                // 1. Prepare samples using Recalculated VelX
                // Use same logic as detectLinesMobile: Mask positive velocity to 0
                const reCalcSamples = reCalcVelX.map((v, i) => ({
                    ts_ms: data[i].t,
                    velX: v < 0 ? v : 0
                }));

                // 2. Run Detection (Use Dynamic K)
                const reCalcResult = detectVelXSpikes(reCalcSamples, { k: kVal, gapMs: 120, expandOneSample: true });

                // 3. Identify Return Sweeps (Filter by Displacement > 100px)
                const candidates = reCalcResult.spikeIntervals.filter(interval => {
                    const sIdx = interval.startIndex;
                    const eIdx = interval.endIndex;
                    if (data[sIdx] && data[eIdx]) {
                        const startX = data[sIdx].x !== null ? data[sIdx].x : 0;
                        const endX = data[eIdx].x !== null ? data[eIdx].x : 0;
                        const displacement = startX - endX;
                        return displacement > 100;
                    }
                    return false;
                });

                // --- Advanced Validation (Algorithm 1 & 2) ---
                // 0. Dynamic Threshold Calculation
                let observedMinLineDur = Infinity;
                let curLineIdxForDur = -1;
                let curLineStartTForDur = -1;

                for (let i = 0; i < data.length; i++) {
                    const d = data[i];
                    if (d.lineIndex !== null && d.lineIndex !== undefined && d.lineIndex !== "") {
                        const idx = Number(d.lineIndex);
                        if (idx !== curLineIdxForDur) {
                            if (curLineIdxForDur !== -1) {
                                const duration = d.t - curLineStartTForDur;
                                if (duration > 50 && duration < observedMinLineDur) {
                                    observedMinLineDur = duration;
                                }
                            }
                            curLineIdxForDur = idx;
                            curLineStartTForDur = d.t;
                        }
                    }
                }
                if (observedMinLineDur === Infinity) observedMinLineDur = 300;

                const MIN_LINE_DURATION = observedMinLineDur * 0.5;
                log(`[Chart11 Dynamic Threshold] MinObserved=${observedMinLineDur}ms -> Threshold=${MIN_LINE_DURATION}ms`);

                const validSweeps = [];
                let currentLineNum = 1;
                let lastSweepEndTime = -Infinity;

                for (const sweep of candidates) {
                    const sweepData = data[sweep.startIndex];
                    const sweepTime = sweepData.t;

                    // Algo 2: Time Gap
                    const timeSinceLast = sweepData.t - lastSweepEndTime;
                    if (validSweeps.length > 0 && timeSinceLast < MIN_LINE_DURATION) {
                        // log(`[Chart11 Reject] Rapid Fire: dt=${timeSinceLast}ms < ${MIN_LINE_DURATION}ms`);
                        continue;
                    }

                    // Algo 1: LineNum Constraint
                    // Note: carry-forward logic is assumed done in load or simple check
                    let currentLineIndex = sweepData.lineIndex;
                    if (currentLineIndex !== null && currentLineIndex !== undefined) {
                        const visibleLinesNow = Number(currentLineIndex) + 1;
                        const targetLineNum = currentLineNum + 1;

                        if (targetLineNum > visibleLinesNow) {
                            // Algorithm 1 Refined: Post-Sweep Validation with Latency Tolerance
                            // Issue: Gaze arrives (Sweep End) slightly before System updates 'LineIndex' (Latency).
                            // Solution: Check a short window (200ms) AFTER Sweep End to see if LineIndex catches up.

                            let validated = false;
                            const toleranceWindow = 200; // ms
                            const searchUntil = sweep.end_ms + toleranceWindow;

                            // Start checking from Sweep End
                            for (let k = sweep.endIndex; k < data.length; k++) {
                                const d = data[k];
                                if (d.t > searchUntil) break;

                                if (d.lineIndex !== null && d.lineIndex !== undefined) {
                                    const vNum = Number(d.lineIndex) + 1;
                                    if (vNum >= targetLineNum) {
                                        validated = true;
                                        break; // System caught up! Valid sweep.
                                    }
                                }
                            }

                            if (!validated) {
                                // Even after waiting, the line index didn't change appropriately. Real Reject.
                                // log(`[Reject Sweep] Premature: Target ${targetLineNum} not reached within ${toleranceWindow}ms after Sweep End.`);
                                continue;
                            }
                        }
                    }

                    validSweeps.push(sweep);
                    lastSweepEndTime = sweep.end_ms;
                    currentLineNum++;
                }

                // 4. Map to Visualization Data
                const detectedSweepPoints = [];
                const sweepIntervalsForShading = [];

                validSweeps.forEach(sw => {
                    sweepIntervalsForShading.push({ start: data[sw.startIndex].t, end: data[sw.endIndex].t });
                    for (let k = sw.startIndex; k <= sw.endIndex; k++) {
                        detectedSweepPoints.push({ x: data[k].t, y: data[k].x }); // Plot on X-graph
                    }
                });

                const ctx11 = createCanvas('chart11', `Chart 11: Independent Return Sweep Detection (RawX + Recalc VelX) [K=${kVal}]`, true);

                // Local Shading Plugin for this chart
                const localShadingPlugin = {
                    id: 'localReturnSweepShading',
                    beforeDatasetsDraw(chart) {
                        const { ctx, chartArea, scales } = chart;
                        if (!chartArea) return;
                        const x = scales.x;
                        ctx.save();
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)'; // Green tint for NEW detection

                        for (const it of sweepIntervalsForShading) {
                            const x0 = x.getPixelForValue(it.start);
                            const x1 = x.getPixelForValue(it.end);
                            if (Number.isFinite(x0) && Number.isFinite(x1)) {
                                ctx.fillRect(Math.min(x0, x1), chartArea.top, Math.abs(x1 - x0), chartArea.bottom - chartArea.top);
                            }
                        }
                        ctx.restore();
                    }
                };

                const chart11 = new Chart(ctx11, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'RawX',
                                data: data.map(d => d.x),
                                borderColor: '#888',
                                borderWidth: 1,
                                pointRadius: 0,
                                yAxisID: 'y'
                            },
                            {
                                label: 'LineIndex',
                                data: data.map(d => d.lineIndex),
                                borderColor: 'orange', // Orange for visibility
                                backgroundColor: 'rgba(255, 165, 0, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                stepped: true,
                                yAxisID: 'y1'
                            },
                            {
                                label: 'Detected RS Points',
                                data: detectedSweepPoints,
                                type: 'scatter',
                                backgroundColor: 'lime', // Bright Green
                                pointStyle: 'rectRot',
                                radius: 4,
                                yAxisID: 'y'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            x: { ticks: { maxTicksLimit: 20 } },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: { display: true, text: 'Raw X (px)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false, // only want the grid lines for one axis to show up
                                },
                                title: { display: true, text: 'Line Index' },
                                min: 0,
                                ticks: { stepSize: 1 }
                            }
                        }
                    },
                    plugins: [localShadingPlugin]
                });
                algoCharts.push(chart11);

                // Inject UI controls after chart is created
                setTimeout(injectChart11Controls, 100);
            }

            // Initial Render
            renderChart11(dynamicK);

            // Expose update function globally or via event
            window.updateChart11K = (newK) => {
                dynamicK = parseFloat(newK);
                if (!isNaN(dynamicK)) {
                    log(`Updating Chart 11 with K=${dynamicK}`);
                    renderChart11(dynamicK);
                }
            };
        }

        // --- 3. UI Events ---
        // UI for Chart 11 (Inserted dynamically above Chart 11)
        function injectChart11Controls() {
            if (document.getElementById('chart11-controls')) return;

            const chart11Canvas = document.getElementById('chart11');
            if (!chart11Canvas) return; // Wait until chart is created

            const wrapper = chart11Canvas.parentNode; // .chart-wrapper
            const container = document.getElementById('charts-container');

            const ctrlDiv = document.createElement('div');
            ctrlDiv.id = 'chart11-controls';
            ctrlDiv.style.margin = '10px 0';
            ctrlDiv.style.padding = '10px';
            ctrlDiv.style.background = '#eee';
            ctrlDiv.style.borderRadius = '4px';
            ctrlDiv.style.textAlign = 'center';
            ctrlDiv.innerHTML = `
                <label style="font-weight:bold; margin-right:10px;">Chart 11 Sensitivity (K):</label>
                <input type="number" id="inputK" value="3.0" step="0.1" style="width:60px;padding:5px; margin-right:10px;">
                <button class="btn" style="padding: 5px 15px;" onclick="window.updateChart11K(document.getElementById('inputK').value)">Update K</button>
            `;

            // Insert BEFORE the Chart 11 wrapper
            container.insertBefore(ctrlDiv, wrapper);
        }

        // Hook into updateChart11K to ensure controls exist? No, create after initial render.
        // We will call this at the end of renderCharts()
        injectChart11Controls(); // Call after initial chart 11 render

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click()); // Area click triggers input

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.background = '#e6f7ff';
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.style.background = '#fff';
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.background = '#fff';
            if (e.dataTransfer.files.length > 0) {
                processFile(e.dataTransfer.files[0]);
            }
        });

    </script>
</body>

</html>