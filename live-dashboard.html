<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Live Eye Tracking Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="./js/firebase-config.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #f0f2f5;
            margin: 0;
            padding: 20px;
        }

        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        h1,
        h2 {
            margin-top: 0;
            color: #333;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        input {
            flex: 1;
            padding: 10px;
            font-size: 1.1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            padding: 10px 20px;
            font-size: 1.1rem;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        #status {
            font-weight: bold;
            margin-bottom: 10px;
        }

        canvas {
            max-height: 400px;
            width: 100%;
        }

        .health-good {
            color: #28a745;
        }

        .health-warn {
            color: #ffc107;
        }

        .health-crit {
            color: #dc3545;
        }
    </style>
</head>

<body>

    <div class="card">
        <h1>‚òÅÔ∏è Live Eye Tracking Dashboard (Firebase)</h1>
        <p>Enter the <b>Session ID</b> displayed on the mobile device to view data instantly.</p>

        <div id="status">Waiting for connection...</div>

        <div class="input-group">
            <input type="text" id="sessionIdInput" placeholder="Enter Session ID (e.g. A1B2)">
            <button onclick="connectSessionFromInput()">Connect</button>
        </div>

        <!-- Recent Sessions List -->
        <div id="recentSessions" style="margin-bottom: 20px;">
            <h3>üïí Recent Sessions</h3>
            <div id="sessionList" style="display:flex; gap:10px; flex-wrap:wrap;">Loading list...</div>
        </div>
    </div>

    <!-- Health Report -->
    <div id="healthReport" class="card" style="display:none; border-left: 5px solid #ccc;"></div>

    <!-- Dashboard -->
    <div id="dashboard" style="display:none;">
        <div class="card">
            <h2>üìâ Chart 1: Return Sweep Analysis (MAD)</h2>
            <canvas id="chart1"></canvas>
        </div>
        <div class="card">
            <h2>üìä Chart 4: Comprehensive Trigger Analysis</h2>
            <p style="color:#666; font-size:0.9em;">
                Green: Raw X (Pos) | Purple: Raw Y (Pos, Hidden) | Blue: Velocity X | Star: Trigger<br>
                <em>Hover over stars to see details (Time, Raw Y, etc). Line Index cleaned.</em>
            </p>
            <canvas id="chart4"></canvas>
        </div>
        <div class="card">
            <h2>üó∫Ô∏è Chart 2: Spatial Path</h2>
            <canvas id="chart2"></canvas>
        </div>
        <div class="card">
            <h2>‚è±Ô∏è Chart 3: Position & Line Index</h2>
            <canvas id="chart3"></canvas>
        </div>
    </div>

    <script>
        // --- Global Chart Instances ---
        let chart1, chart2, chart3, chart4;

        // --- Init ---
        window.onload = function () {
            if (!window.firebase || !window.FIREBASE_CONFIG) {
                alert("Firebase Config Missing!");
                return;
            }
            if (!firebase.apps.length) firebase.initializeApp(window.FIREBASE_CONFIG);

            // Listen for Recent Sessions
            const db = firebase.database();
            const listRef = db.ref('sessions').orderByChild('meta/timestamp').limitToLast(10);

            listRef.on('value', (snapshot) => {
                const listEl = document.getElementById('sessionList');
                listEl.innerHTML = "";

                const sessions = [];
                snapshot.forEach(child => {
                    sessions.push({ key: child.key, val: child.val() });
                });

                // Reverse to show newest first
                sessions.reverse().forEach(item => {
                    const btn = document.createElement("button");
                    const timeStr = item.val.meta ? new Date(item.val.meta.timestamp).toLocaleTimeString() : "???";
                    const agent = item.val.meta && item.val.meta.userAgent ? getDeviceName(item.val.meta.userAgent) : "Unknown";

                    btn.innerHTML = `<b>${item.key}</b><br><small>${timeStr}</small><br><span style='font-size:0.8em; color:#ddd'>${agent}</span>`;
                    btn.style.cssText = "background:#555; text-align:left; line-height:1.2;";
                    btn.onclick = () => loadSession(item.key);
                    listEl.appendChild(btn);
                });

                if (sessions.length === 0) listEl.innerText = "No sessions found yet. Play the game to upload data.";
            });
        };

        function getDeviceName(ua) {
            if (/Android/i.test(ua)) return "üì± Android";
            if (/iPhone/i.test(ua)) return "üì± iPhone";
            if (/Windows/i.test(ua)) return "üíª PC";
            return "Unknown Device";
        }

        function connectSessionFromInput() {
            const id = document.getElementById('sessionIdInput').value.trim();
            if (id) loadSession(id);
        }

        // --- Firebase Logic ---
        function loadSession(sessionId) {
            // Update Input
            document.getElementById('sessionIdInput').value = sessionId;

            const db = firebase.database();
            document.getElementById('status').innerText = `Connecting to [${sessionId}]...`;

            // Listen for changes
            const ref = db.ref('sessions/' + sessionId);
            ref.off(); // Detach previous listeners if any (simple approach)
            ref.on('value', (snapshot) => {
                const val = snapshot.val();
                if (val) {
                    document.getElementById('status').innerHTML = `‚úÖ Data Received! Last Update: ${new Date(val.meta.timestamp).toLocaleTimeString()}`;
                    // Process Data
                    processData(val.data);
                } else {
                    document.getElementById('status').innerText = `‚ö†Ô∏è Session [${sessionId}] not found or empty.`;
                }
            });
        }

        // --- Data Processing Setup ---
        function processData(rawData) {
            if (!rawData || !Array.isArray(rawData)) return;

            let lastLineIndex = 0;

            const data = rawData.map(d => {
                // Fix Line Index Jitter: If -1 (lost track), use last known good index
                let li = d.lineIndex;
                if (li === undefined || li < 0) {
                    li = lastLineIndex;
                } else {
                    lastLineIndex = li;
                }

                return {
                    ...d,
                    t: Number(d.t),
                    x: Number(d.x),
                    y: Number(d.y),
                    vx: Number(d.vx),
                    lineIndex: li, // Cleaned Line Index
                    dbgThresh: d.debugThreshold,
                    dbgVX: d.debugVX,
                    didFire: d.didFire
                };
            });

            analyzeDataHealth(data);
            renderCharts(data);
            document.getElementById('dashboard').style.display = 'block';
        }

        // --- Health Check (Copied) ---
        function analyzeDataHealth(data) {
            if (data.length < 2) return;
            let timeReversals = 0, largeGaps = 0, maxGap = 0, sumGap = 0;

            for (let i = 1; i < data.length; i++) {
                const dt = data[i].t - data[i - 1].t;
                if (dt < 0) timeReversals++;
                if (dt > 100) largeGaps++;
                if (dt > maxGap) maxGap = dt;
                sumGap += dt;
            }

            const avgGap = sumGap / (data.length - 1);
            const hz = avgGap > 0 ? (1000 / avgGap).toFixed(1) : 0;

            let status = "GOOD", color = "#28a745";
            if (timeReversals > 0 || largeGaps > data.length * 0.1) { status = "WARNING"; color = "#ffc107"; }
            if (avgGap > 100) { status = "CRITICAL"; color = "#dc3545"; }

            const report = document.getElementById('healthReport');
            report.style.display = 'block';
            report.borderColor = color;
            report.innerHTML = `
            <h3 style="color:${color}; margin-top:0;">ü©∫ Health: ${status}</h3>
            <div>Hz: <b>${hz}</b> | Max Gap: <b>${maxGap}ms</b> | Samples: <b>${data.length}</b></div>
        `;
        }

        // --- Chart Rendering ---
        function renderCharts(data) {
            // 1. Calculate Delta Negative VX (Acceleration in negative zone)
            for (let i = 1; i < data.length; i++) {
                const curr = data[i];
                const prev = data[i - 1];
                // Calculate only if BOTH are negative (continuous negative zone)
                if (curr.vx !== undefined && prev.vx !== undefined && curr.vx < 0 && prev.vx < 0) {
                    // Start of sweep (moving left) -> vx becomes MORE negative -> Delta = (-) - (-)
                    // E.g. -1 -> -5 => Delta = -4 (Accel)
                    // E.g. -5 -> -1 => Delta = +4 (Decel)
                    curr.deltaNegVX = curr.vx - prev.vx;
                } else {
                    curr.deltaNegVX = null;
                }
            }

            // Register Plugin globally but DISABLE it by default
            if (window.ChartDataLabels) {
                Chart.register(ChartDataLabels);
                Chart.defaults.set('plugins.datalabels', { display: false });
            }

            // Destroy old
            if (chart1) chart1.destroy();
            if (chart2) chart2.destroy();
            if (chart3) chart3.destroy();
            if (chart4) chart4.destroy();

            const labels = data.map(d => d.t);
            const triggers = data.map(d => d.didFire ? d.vx : null);

            // Chart 1: MAD Analysis
            chart1 = new Chart(document.getElementById('chart1'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Realtime VX', data: data.map(d => d.vx), borderColor: '#36a2eb', borderWidth: 1, pointRadius: 0, datalabels: { display: false } },
                        { label: 'Threshold', data: data.map(d => d.dbgThresh), borderColor: '#ff6384', borderDash: [5, 5], borderWidth: 1, pointRadius: 0, datalabels: { display: false } },
                        { label: 'Triggered', data: triggers, type: 'scatter', pointStyle: 'star', radius: 8, backgroundColor: 'gold', datalabels: { display: false } }
                    ]
                },
                options: { animation: false, interaction: { mode: 'index', intersect: false } }
            });

            // Chart 4: Comprehensive Trigger Analysis (Enhanced Tooltips)
            chart4 = new Chart(document.getElementById('chart4'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        // Disable datalabels for normal lines
                        { label: 'Raw X', data: data.map(d => d.x), borderColor: '#28a745', borderWidth: 1.5, pointRadius: 0, yAxisID: 'yPos', datalabels: { display: false } },
                        { label: 'Line Index', data: data.map(d => d.lineIndex), borderColor: '#fd7e14', borderWidth: 2, pointRadius: 0, stepped: true, yAxisID: 'yLine', datalabels: { display: false } },
                        { label: 'Raw Y', data: data.map(d => d.y), borderColor: '#6f42c1', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], yAxisID: 'yPos', hidden: true, datalabels: { display: false } },
                        { label: 'Velocity X', data: data.map(d => d.vx), borderColor: 'rgba(54, 162, 235, 0.5)', backgroundColor: 'rgba(54, 162, 235, 0.1)', borderWidth: 1, pointRadius: 0, fill: true, yAxisID: 'yVel', datalabels: { display: false } },

                        // NEW: Delta Negative Velocity (Acceleration)
                        {
                            label: 'Delta Neg VX (Accel)',
                            data: data.map(d => d.deltaNegVX),
                            type: 'line',
                            borderColor: '#8e44ad', // Purple
                            backgroundColor: 'rgba(142, 68, 173, 0.2)',
                            borderWidth: 1.5,
                            pointRadius: 1,
                            fill: false,
                            yAxisID: 'yVel',
                            datalabels: { display: false }
                        },
                        // NEW: Modified Z-Score Analysis (Right Axis)
                        {
                            label: 'Modified Z-Score',
                            data: data.map(d => d.debugZScore),
                            type: 'line',
                            borderColor: '#34495e', // Dark Navy
                            borderWidth: 1,
                            borderDash: [2, 2],
                            pointRadius: 0,
                            yAxisID: 'yZScore',
                            hidden: false,
                            datalabels: { display: false }
                        },
                        // NEW: Negative Velocity Highlights (Scatter)
                        {
                            label: 'Neg Vel X (<0)',
                            data: data.map(d => (d.vx < 0 ? d.vx : null)),
                            type: 'scatter',
                            pointStyle: 'cross',
                            radius: 2,
                            borderColor: 'rgba(255, 99, 132, 1)', // Red
                            backgroundColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            yAxisID: 'yVel',
                            datalabels: { display: false }
                        },
                        // NEW: MAD Threshold Line (Connects debug points)
                        {
                            label: 'MAD Threshold (K=1.5)',
                            data: data.map(d => d.dbgThresh),
                            type: 'line',
                            borderColor: '#ff0000',
                            borderDash: [4, 4],
                            borderWidth: 1.5,
                            pointRadius: 0,
                            spanGaps: true, // Connect gaps between checks
                            yAxisID: 'yVel',
                            datalabels: { display: false }
                        },

                        {
                            label: 'Trigger Event',
                            data: data.map(d => d.didFire ? d.x : null),

                            type: 'scatter',
                            pointStyle: 'circle',
                            radius: 3,
                            backgroundColor: 'red',
                            borderColor: 'red',
                            borderWidth: 0,
                            yAxisID: 'yPos',
                            // Enable datalabels ONLY for this dataset
                            datalabels: {
                                display: function (context) {
                                    // Logic: Show label only on the FIRST point of a continuous trigger burst
                                    const idx = context.dataIndex;
                                    if (idx === 0) return true; // Start of data
                                    const curr = data[idx];
                                    const prev = data[idx - 1];

                                    // If previous frame did NOT fire, this is a start of a new event -> Show
                                    if (!prev.didFire && curr.didFire) return true;

                                    // Or if time gap is large (> 200ms)
                                    if ((curr.t - prev.t) > 200) return true;

                                    return false;
                                },
                                formatter: function (value, context) {
                                    return Math.round(data[context.dataIndex].t);
                                },
                                align: 'top',
                                anchor: 'center',
                                color: 'red',
                                font: {
                                    weight: 'bold',
                                    size: 10
                                },
                                offset: 4
                            }
                        }
                    ]
                },
                options: {
                    animation: false,
                    interaction: { mode: 'nearest', intersect: true },
                    scales: {
                        x: { ticks: { maxTicksLimit: 20 } },
                        yPos: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Position (px)' } },
                        yVel: { type: 'linear', display: true, position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: 'Velocity (px/ms)' } },
                        yZScore: { type: 'linear', display: true, position: 'right', min: -10, max: 5, grid: { drawOnChartArea: false }, title: { display: true, text: 'Z-Score' } },
                        yLine: { type: 'linear', display: true, position: 'right', min: 0, max: 10, grid: { drawOnChartArea: false }, title: { display: true, text: 'Line Index' } }
                    },
                    plugins: {
                        datalabels: {
                            // Default global setting for this chart (safety)
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const idx = context.dataIndex;
                                    const raw = data[idx];
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    // Add extra details for Triggers
                                    if (context.dataset.label === 'Trigger Event') {
                                        return [
                                            `üåü TRIGGERED!`,
                                            `Time: ${raw.t}`,
                                            `Raw Y: ${raw.y.toFixed(1)}`,
                                            `Velocity: ${raw.vx.toFixed(2)}`,
                                            `Thresh: ${raw.dbgThresh ? raw.dbgThresh.toFixed(2) : 'N/A'}`
                                        ];
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            // Chart 2: Spatial
            chart2 = new Chart(document.getElementById('chart2'), {
                type: 'scatter',
                data: {
                    datasets: [
                        { label: 'Gaze Path', data: data.map(d => ({ x: d.x, y: d.y })), borderColor: '#ccc', borderWidth: 1, showLine: true, pointRadius: 1 },
                        { label: 'Trigger Points', data: data.filter(d => d.didFire).map(d => ({ x: d.x, y: d.y })), backgroundColor: 'gold', pointRadius: 6 }
                    ]
                },
                options: {
                    scales: {
                        y: { reverse: true, min: 0, max: window.innerHeight },
                        x: { min: 0, max: window.innerWidth }
                    },
                    animation: false
                }
            });

            // Chart 3: Position & Line Index
            chart3 = new Chart(document.getElementById('chart3'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Raw X', data: data.map(d => d.x), borderColor: '#28a745', borderWidth: 1, yAxisID: 'y' },
                        { label: 'Line Index', data: data.map(d => d.lineIndex), borderColor: '#fd7e14', borderWidth: 2, stepper: true, yAxisID: 'y1' }
                    ]
                },
                options: {
                    animation: false,
                    scales: {
                        y: { type: 'linear', display: true, position: 'left' },
                        y1: { type: 'linear', display: true, position: 'right', min: 0, max: 10 }
                    }
                }
            });
        }
    </script>
</body>

</html>